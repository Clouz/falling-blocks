<!DOCTYPE html><html lang="it" data-theme="dark">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#0e0e12" id="themeColor" />
  <link rel="manifest" href="manifest.json">
  <title>Falling Blocks – v8.5 PWA</title>
  <style>
    :root{ --bg:#0e0e12; --panel:#14141b; --card:#1a1a22; --fg:#e9e9ef; --acc:#3a86ff; --grid:#ffffff14; }
    [data-theme="light"]{ --bg:#f7f7fb; --panel:#ffffff; --card:#ffffff; --fg:#0f1020; --acc:#3a86ff; --grid:#00000014; }
    html, body { margin:0; padding:0; background:var(--bg); height:100%; color:var(--fg); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif }
    #wrap { display:flex; flex-direction:column; align-items:center; gap:10px; padding:10px }
    #hud { display:flex; width:100%; max-width:520px; gap:8px; align-items:center; justify-content:space-between; flex-wrap:wrap }
    .box { background:var(--card); padding:8px 10px; border-radius:12px; min-width:88px; text-align:center }
    .big { font-weight:800; font-size:18px }
    .pill { background:rgba(58,134,255,.16); border:1px solid rgba(58,134,255,.35); color:var(--fg); padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px; display:none }
    button { appearance:none; border:0; background:var(--acc); color:#fff; padding:10px 14px; font-weight:800; border-radius:12px }
    #game { position:relative }
    canvas { background:var(--panel); border-radius:16px; box-shadow:0 6px 20px rgba(0,0,0,.2); touch-action:none }
    #hint { opacity:.75; font-size:12px; text-align:center; max-width:520px; line-height:1.3 }
    #pause { position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); border-radius:16px; font-size:20px; font-weight:800; text-align:center; white-space:pre-line; padding:20px }
    dialog { border:0; border-radius:16px; background:var(--card); color:var(--fg); width:min(92vw, 520px); }
    dialog::backdrop { background:rgba(0,0,0,.45); }
    .row { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 0; }
    .row + .row { border-top: 1px solid #26263522; }
    label { font-weight:600; }
    input[type=range] { width: 160px; }
    select, input[type=checkbox] { accent-color: var(--acc); }
  </style>
</head>
<body>
  <div id="wrap">
    <div id="hud">
      <div class="box"><div>Livello</div><div class="big" id="level">1</div></div>
      <div class="box"><div>Punti</div><div class="big" id="score">0</div></div>
      <div class="box"><div>Linee</div><div class="big" id="lines">0</div></div>
      <div class="box"><div>Record</div><div class="big" id="best">0</div></div>
      <div style="display:flex; gap:8px">
        <button id="btn" title="Pausa / Riprendi">⏸︎/▶︎</button>
        <button id="optBtn" title="Opzioni">⚙️ Opzioni</button>
        <button id="installBtn" style="display:none">⬇︎ Installa</button>
      </div>
    </div>
    <div id="game" style="position:relative">
      <canvas id="c"></canvas>
      <div id="pause">PAUSA</div>
      <div class="pill" id="comboPill" style="position:absolute; right:8px; top:8px; z-index:5; pointer-events:none; display:none">Combo x1</div>
    </div>
    <div id="hint">Mobile: trascina ←/→ per muovere • Tap = ruota • Swipe ↓ = caduta (soft/hard da Opzioni). PC: ←/→ muovi, ↑ ruota, ↓ soft-drop, Space hard-drop</div>
    <div id="debug" style="display:none;font-family:monospace; font-size:12px; max-width:520px; background:#0006; padding:6px 8px; border-radius:8px; white-space:pre-wrap">[DEBUG] avvio</div>
  </div>  <dialog id="optModal">
    <form method="dialog" style="padding:16px">
      <h3 style="margin-top:0">Opzioni</h3>
      <div class="row">
        <label for="sens">Sensibilità movimento</label>
        <div><input id="sens" type="range" min="8" max="36" step="2"><span id="sensVal" style="margin-left:10px"></span></div>
      </div>
      <div class="row">
        <label for="dropMode">Caduta swipe ↓</label>
        <select id="dropMode">
          <option value="hard">Hard drop</option>
          <option value="soft">Soft drop</option>
        </select>
      </div>
      <div class="row">
        <label for="gridToggle">Griglia</label>
        <input id="gridToggle" type="checkbox">
      </div>
      <div class="row">
        <label for="themeSel">Tema</label>
        <select id="themeSel">
          <option value="dark">Scuro</option>
          <option value="light">Chiaro</option>
          <option value="system">Sistema</option>
        </select>
      </div>
      <div class="row">
        <label for="startLevelSel">Start level (NES)</label>
        <select id="startLevelSel"></select>
      </div>
      <div class="row">
        <label for="dbgToggle">Schermata debug</label>
        <input id="dbgToggle" type="checkbox">
      </div>
      <div class="row">
        <label for="lockStyle">Lock delay</label>
        <select id="lockStyle">
          <option value="nes">NES (illimitato)</option>
          <option value="modern">Moderno (limite reset)</option>
        </select>
      </div>
      <div class="row">
        <label for="lockDelay">Durata lock (ms)</label>
        <div><input id="lockDelay" type="range" min="100" max="1000" step="50"><span id="lockDelayVal" style="margin-left:10px"></span></div>
      </div>
      <div class="row" id="lockMaxRow">
        <label for="lockMaxResets">Max reset (moderno)</label>
        <div><input id="lockMaxResets" type="range" min="1" max="30" step="1"><span id="lockMaxVal" style="margin-left:10px"></span></div>
      </div>
      <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:14px">
        <button value="cancel" formnovalidate>Annulla</button>
        <button id="saveBtn" value="default">Salva</button>
      </div>
    </form>
  </dialog><script>
/* ====================== SETTINGS & THEME ====================== */
const SETTINGS_KEY='fb_settings_v85';
const DefaultSettings = { hstep:18, dropMode:'hard', debug:false, grid:true, theme:'dark', startLevel:0, lockDelay:500, lockStyle:'nes', lockMaxResets:15 };
let settings = loadSettings();
function loadSettings(){ try{ const s=JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}'); return Object.assign({}, DefaultSettings, s); }catch(_){ return {...DefaultSettings}; } }
function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }

const dbgEl = document.getElementById('debug');
function dbg(msg){ if(!settings.debug) return; console.log('[FB]', msg); dbgEl.textContent += '\n' + msg; }

function applyTheme(){
  let theme = settings.theme;
  if(theme==='system') theme = window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
  document.documentElement.setAttribute('data-theme', theme);
  document.getElementById('themeColor').setAttribute('content', theme==='light' ? '#ffffff' : '#0e0e12');
}
applyTheme();
window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', ()=>{ if(settings.theme==='system') applyTheme(); });

/* ====================== CONFIG ====================== */
const COLS=10, ROWS=20;
const COLORS=["#000000","#00d1ff","#f9c80e","#ff6b6b","#6a4c93","#2ec4b6","#ffd166","#06d6a0"];
const SCORE_TABLE={1:100,2:300,3:500,4:800};
const CLEAR_ANIM_MS = 120; // flash rapido sull'intera riga
const SWIPE_DOWN_PX=40; const TAP_MAX_MOVE=10, TAP_MAX_MS=250; const TAP_MAX_RADIUS=6;
// Soft drop tuning
const SOFT_DROP_FACTOR = 0.6;   // il soft drop usa il 60% della gravità attuale (più lento dell'hard/gravità massima)
const SOFT_DROP_MIN_MS = 140;   // non scendere mai sotto questo valore per soft drop

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
const pauseOverlay=document.getElementById('pause');
const btn=document.getElementById('btn');
const optBtn=document.getElementById('optBtn');
const optModal=document.getElementById('optModal');
const sensInput=document.getElementById('sens');
const sensVal=document.getElementById('sensVal');
const dropSelect=document.getElementById('dropMode');
const gridToggle=document.getElementById('gridToggle');
const themeSel=document.getElementById('themeSel');
const dbgToggle=document.getElementById('dbgToggle');
const startLevelSel=document.getElementById('startLevelSel');
const lockStyleSel=document.getElementById('lockStyle');
const lockDelayInput=document.getElementById('lockDelay');
const lockDelayVal=document.getElementById('lockDelayVal');
const lockMaxResetsInput=document.getElementById('lockMaxResets');
const lockMaxVal=document.getElementById('lockMaxVal');
const installBtn=document.getElementById('installBtn');
const comboPill=document.getElementById('comboPill');

// populate start level 0..19
for(let i=0;i<=19;i++){ const o=document.createElement('option'); o.value=String(i); o.textContent=String(i); startLevelSel.appendChild(o);} 

function refreshOptionsUI(){
  sensInput.value = String(settings.hstep); sensVal.textContent = settings.hstep+' px';
  dropSelect.value = settings.dropMode; gridToggle.checked=settings.grid; themeSel.value=settings.theme;
  dbgToggle.checked = settings.debug; startLevelSel.value=String(settings.startLevel);
  lockStyleSel.value = settings.lockStyle;
  lockDelayInput.value = String(settings.lockDelay); lockDelayVal.textContent = settings.lockDelay+' ms';
  lockMaxResetsInput.value = String(settings.lockMaxResets); lockMaxVal.textContent = settings.lockMaxResets;
  document.getElementById('lockMaxRow').style.display = (settings.lockStyle==='modern') ? 'flex' : 'none';
  dbgEl.style.display = settings.debug ? 'block' : 'none';
}
refreshOptionsUI();

optBtn.addEventListener('click', ()=>{ refreshOptionsUI(); optModal.showModal(); });

document.getElementById('saveBtn').addEventListener('click', (e)=>{
  e.preventDefault();
  settings.hstep=parseInt(sensInput.value,10);
  settings.dropMode=dropSelect.value; settings.grid=!!gridToggle.checked; settings.theme=themeSel.value;
  settings.debug=!!dbgToggle.checked; settings.startLevel=parseInt(startLevelSel.value,10);
  settings.lockStyle = lockStyleSel.value;
  settings.lockDelay = parseInt(lockDelayInput.value,10);
  settings.lockMaxResets = parseInt(lockMaxResetsInput.value,10);
  saveSettings(); applyTheme(); refreshOptionsUI(); optModal.close();
  if(st.paused||st.over) { startGame(); pauseOverlay.style.display='none'; }
});
lockStyleSel.addEventListener('change', ()=>{ settings.lockStyle = lockStyleSel.value; refreshOptionsUI(); });
lockDelayInput.addEventListener('input', ()=>{ lockDelayVal.textContent = lockDelayInput.value+' ms'; });
lockMaxResetsInput.addEventListener('input', ()=>{ lockMaxVal.textContent = lockMaxResetsInput.value; });

/* ====================== LAYOUT ====================== */
let CELL=28, SIDE_W=0, TOTAL_W=0, TOTAL_H=0;
function resizeCanvas(){ const maxW=Math.min(520, window.innerWidth-20); CELL=Math.floor(maxW/(COLS+6)); SIDE_W=CELL*5; TOTAL_W=CELL*COLS + SIDE_W + CELL; TOTAL_H=CELL*(ROWS+2); canvas.width=TOTAL_W; canvas.height=TOTAL_H; dbg('resize: CELL='+CELL+' W='+TOTAL_W+' H='+TOTAL_H); }
window.addEventListener('resize', resizeCanvas); resizeCanvas();

/* ====================== PIECES ====================== */
const ROT = { O:[[[1,1],[1,1]]], I:[[[1,1,1,1]], [[1],[1],[1],[1]]], S:[[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]], Z:[[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]], L:[[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]], J:[[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]], T:[[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]], };
const PIECES=['I','O','T','S','Z','J','L'];
function newBag(){ const b=PIECES.slice(); for(let i=b.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [b[i],b[j]]=[b[j],b[i]]; } return b; }
function makePiece(type){ const r=0; const s=ROT[type][r]; const color=PIECES.indexOf(type)+1; const x=((COLS-s[0].length)/2)|0; const y=-2; return {type,r,x,y,color}; }

/* ====================== STATE ====================== */
function emptyBoard(){ const b=[]; for(let y=0;y<ROWS;y++){ const row=new Array(COLS); for(let x=0;x<COLS;x++) row[x]=0; b.push(row);} return b; }
let st={ board:emptyBoard(), cur:null, next:makePiece('I'), bag:newBag(), score:0, lines:0, level:1, best:Number(localStorage.getItem('fb_highscore')||0), dropMs:800, accMs:0, paused:false, over:false, startLevel:settings.startLevel, combo:0, b2b:false, clearAnim:null, grounded:false, lockT:0, lockResets:0, softDropping:false };

// opzionale: override da URL ?start=...
(function(){ const m = new URLSearchParams(location.search).get('start'); const n = m!=null ? Math.max(0, Math.min(19, parseInt(m,10)||0)) : null; if(n!=null){ st.startLevel = n; settings.startLevel = n; saveSettings(); } })();

function updateHUD(){ document.getElementById('score').textContent = st.score; document.getElementById('lines').textContent = st.lines; document.getElementById('best').textContent = st.best; document.getElementById('level').textContent = st.level; comboPill.style.display = st.combo>1 ? 'inline-flex' : 'none'; comboPill.textContent = 'Combo x'+st.combo; }

/* ====================== NES SPEED & LEVEL ====================== */
function nesDropMsForLevel(level){ let frames; if (level <= 9) { const table = [48,43,38,33,28,23,18,13,8,6]; frames = table[level]; } else if (level <= 12) frames = 5; else if (level <= 15) frames = 4; else if (level <= 18) frames = 3; else if (level <= 28) frames = 2; else frames = 1; const ms = Math.round(frames * 1000 / 60); return Math.max(60, ms); }
function setLevelByLines(){ const L0 = st.startLevel; const firstGoal = Math.min(L0*10 + 10, Math.max(100, L0*10 - 50)); let newLevel; if (st.lines < firstGoal) newLevel = L0; else newLevel = L0 + 1 + Math.floor((st.lines - firstGoal)/10); const prev = st.level; st.level = Math.max(L0, newLevel); const newMs = nesDropMsForLevel(st.level); if(st.dropMs !== newMs){ st.dropMs=newMs; st.accMs=0; } }

function currentShape(){ return ROT[st.cur.type][st.cur.r]; }
function spawnFromNext(){ st.cur = Object.assign({}, st.next); const s=currentShape(); st.cur.x=((COLS-s[0].length)/2)|0; st.cur.y=-2; }
function refillNext(){ if(st.bag.length===0) st.bag=newBag(); const t=st.bag.pop(); st.next = makePiece(t); }
function startGame(){ st.board=emptyBoard(); st.score=0; st.lines=0; st.level=st.startLevel=settings.startLevel; st.dropMs=nesDropMsForLevel(st.level); st.accMs=0; st.paused=false; st.over=false; st.combo=0; st.b2b=false; st.clearAnim=null; st.grounded=false; st.lockT=0; st.lockResets=0; st.softDropping=false; updateHUD(); st.bag=newBag(); st.next=makePiece('I'); spawnFromNext(); refillNext(); }

/* ====================== COLLISIONS & MOVES ====================== */
function collides(p=st.cur, dx=0, dy=0, r=p.r){ const shape=ROT[p.type][r]; for(let y=0;y<shape.length;y++){ for(let x=0;x<shape[0].length;x++){ if(!shape[y][x]) continue; const nx=p.x+x+dx, ny=p.y+y+dy; if(ny<0) continue; if(nx<0||nx>=COLS||ny>=ROWS) return true; if(st.board[ny][nx]) return true; } } return false; }
function tryMove(dx,dy){ if(!collides(st.cur,dx,dy,st.cur.r)){ st.cur.x+=dx; st.cur.y+=dy; if(dx!==0 && dy===0) onGroundNudge(); return true;} return false; }
function tryRotate(){ let nr=(st.cur.r+1)%ROT[st.cur.type].length; const moved = (!collides(st.cur,0,0,nr)) ? (st.cur.r=nr,true)
              : (!collides(st.cur,-1,0,nr)) ? (st.cur.x-=1, st.cur.r=nr, true)
              : (!collides(st.cur,1,0,nr)) ? (st.cur.x+=1, st.cur.r=nr, true)
              : false; if(moved) onGroundNudge(); return moved; }
function hardDrop(){ let d=0; while(!collides(st.cur,0,1,st.cur.r)){ st.cur.y++; d++; } st.grounded=false; st.lockT=0; st.lockResets=0; lockPiece(); st.score += 2*d; if(st.score>st.best){ st.best=st.score; localStorage.setItem('fb_highscore', String(st.best)); } updateHUD(); }
function softDropStep(){ if(tryMove(0,1)) { st.score += 1; if(st.score>st.best){ st.best=st.score; localStorage.setItem('fb_highscore', String(st.best)); } updateHUD(); st.grounded=false; st.lockT=0; } else { beginGrounding(); } }

/* ====================== LINE CLEAR (anim + commit) ====================== */
function getFullRows(){ const rows=[]; for(let y=ROWS-1;y>=0;y--){ if(st.board[y].every(v=>v!==0)) rows.push(y); } return rows; }
function startClearAnim(rows){ const uniq = Array.from(new Set(rows)).sort((a,b)=>a-b); st.clearAnim = { rows: uniq, t: 0, dur: CLEAR_ANIM_MS, active: true }; }
function commitClearRows(rows){ if (!rows || !rows.length) { st.combo = 0; spawnFromNext(); refillNext(); return; } const kill = new Set(rows); const kept=[]; for(let y=0;y<ROWS;y++){ if(!kill.has(y)) kept.push(st.board[y]); } while(kept.length < ROWS) kept.unshift(new Array(COLS).fill(0)); st.board = kept; const cleared = rows.length; st.lines += cleared; let base = (SCORE_TABLE[cleared] || 0) * st.level; const difficult = (cleared === 4); if (difficult && st.b2b) base = Math.round(base * 1.5); st.b2b = difficult ? true : false; st.combo = (st.combo||0) + 1; const comboBonus = 50 * st.combo * st.level; st.score += base + comboBonus; setLevelByLines(); if(st.score>st.best){ st.best=st.score; localStorage.setItem('fb_highscore', String(st.best)); } updateHUD(); st.clearAnim = null; spawnFromNext(); refillNext(); }

function lockPiece(){ const s=currentShape(); let overflow=false; for(let y=0;y<s.length;y++){ for(let x=0;x<s[0].length;x++){ if(s[y][x]){ const by=st.cur.y+y; if(by<0){ overflow=true; } else { st.board[by][st.cur.x+x]=st.cur.color; } } } } st.grounded=false; st.lockT=0; st.lockResets=0; if(overflow){ return gameOver(); } const rows = getFullRows(); if(rows.length){ startClearAnim(rows); } else { st.combo = 0; spawnFromNext(); refillNext(); } }

/* ====================== DRAW ====================== */
function draw(){ const offX=CELL, offY=CELL; ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--panel').trim()||'#14141b'; ctx.fillRect(offX-2,offY-2,CELL*COLS+4,CELL*ROWS+4);
  if(settings.grid){ ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid').trim()||'#ffffff14'; ctx.lineWidth=1; for(let x=0;x<=COLS;x++){ ctx.beginPath(); ctx.moveTo(offX+x*CELL, offY); ctx.lineTo(offX+x*CELL, offY+ROWS*CELL); ctx.stroke(); } for(let y=0;y<=ROWS;y++){ ctx.beginPath(); ctx.moveTo(offX, offY+y*CELL); ctx.lineTo(offX+COLS*CELL, offY+y*CELL); ctx.stroke(); } }
  for(let y=0;y<ROWS;y++){ for(let x=0;x<COLS;x++){ const v=st.board[y][x]; if(v){ drawCell(offX+x*CELL, offY+y*CELL, COLORS[v], 1); } } }
  if(st.cur){ let gy=st.cur.y; while(!collides(st.cur,0,gy-st.cur.y+1,st.cur.r)) gy++; const s=currentShape(); for(let y=0;y<s.length;y++){ for(let x=0;x<s[0].length;x++){ if(s[y][x]){ const px=offX+(st.cur.x+x)*CELL, py=offY+(gy+y)*CELL; if(gy+y>=0) drawCell(px,py,COLORS[st.cur.color], 0.25); } } } for(let y=0;y<s.length;y++){ for(let x=0;x<s[0].length;x++){ if(s[y][x]){ const px=offX+(st.cur.x+x)*CELL, py=offY+(st.cur.y+y)*CELL; if(st.cur.y+y>=0) drawCell(px,py,COLORS[st.cur.color], 1); } } } }
  // Flash intero sulle righe che stanno per sparire
  if(st.clearAnim){ const p = Math.min(1, st.clearAnim.t / st.clearAnim.dur); const alpha = 0.5 * (1 - p); ctx.globalAlpha = alpha; ctx.fillStyle = '#ffffff'; for(const y of st.clearAnim.rows){ const rowY = offY + y*CELL; ctx.fillRect(offX, rowY, COLS*CELL, CELL); } ctx.globalAlpha = 1; }
}
function drawCell(x,y,color,alpha=1){ const r=CELL*0.18; ctx.globalAlpha = alpha; ctx.fillStyle=color; roundRect(ctx,x+1,y+1,CELL-2,CELL-2,r,true,false); ctx.globalAlpha = alpha * 0.18; ctx.fillStyle="#fff"; roundRect(ctx,x+3,y+3,CELL-6,CELL-6,r,true,false); ctx.globalAlpha = 1; }
function roundRect(ctx,x,y,w,h,r,fill,stroke){ if(w<2*r) r=w/2; if(h<2*r) r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+
